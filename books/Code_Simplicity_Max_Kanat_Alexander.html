<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio</title>
    <link rel="stylesheet" href="../styles/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" integrity="sha512-1ycn6IcaQQ40/MKBW2W4Rhis/DbILU74C1vSrLJxCq57o941Ym01SwNsOMqvEBFlcgUa6xLiPY/NS5R+E6ztJQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800&display=swap" rel="stylesheet">
</head>
<body class="main-content">
    <main>
        <section class="container active book" id="book">
            <div class="main-title">
                <h2>Code Simplicity <br><span>Max Kanat-Alexander</span><span class="bg-text">Books</span></h2>
            </div>
            <div class="book-container">
                    <h4></h4>
                    <p>
                        Nel mondo dello sviluppo software, la semplicit√† √® spesso sottovalutata, eppure √® uno degli elementi pi√π importanti per scrivere codice di qualit√†, scalabile e mantenibile. Code Simplicity di Max Kanat-Alexander affronta questo tema in modo diretto e accessibile, offrendo principi universali per la progettazione di software che resista alla prova del tempo.
                    </p>
                    <br>
                    <h4></h4>
                    <p>
                        Il libro non √® un manuale tecnico, n√© una raccolta di best practices specifiche, ma un‚Äôopera che esplora le fondamenta della progettazione del software da un punto di vista pi√π filosofico e concettuale. Kanat-Alexander, ex Lead Architect di Bugzilla e ingegnere di Google, parte da una domanda chiave: come possiamo costruire software che sia semplice, efficace e sostenibile nel lungo periodo?
                        Attraverso una serie di riflessioni e principi, l‚Äôautore costruisce una teoria della semplicit√† nel software, mettendo in luce come la complessit√† sia il nemico principale di ogni programmatore.
                    </p>
                    <br>
                    <h4></h4>
                    <p>
                        üîπ<b>Il Valore della Semplicit√†</b><br>
                        L'autore sostiene che la semplicit√† √® il principio pi√π importante nello sviluppo software. Un codice semplice √® pi√π facile da leggere, mantenere ed estendere nel tempo. Troppa complessit√† porta a inefficienza, errori e difficolt√† nella gestione dei progetti.
                        <br><br>üîπ <b>Leggi Fondamentali dello Sviluppo Software</b><br>
                        Kanat-Alexander introduce alcune leggi universali che regolano il modo in cui il software viene progettato e sviluppato. Una delle pi√π importanti √®: Ogni modifica al codice deve essere un miglioramento rispetto allo stato attuale. In altre parole, ogni aggiornamento dovrebbe ridurre la complessit√† e migliorare la leggibilit√†, mai il contrario.
                        <br><br>üîπ<b>La Relazione tra Complessit√† e Costi</b><br>
                        L‚Äôautore dimostra come la complessit√† influisca direttamente sul costo di sviluppo e manutenzione di un software. Un codice complesso pu√≤ funzionare inizialmente, ma con il tempo diventa difficile da gestire, rallentando il team e aumentando il rischio di bug critici.
                        <br><br>üîπ <b>Decisioni Tecniche Basate su Principi</b><br>
                        Il libro enfatizza l‚Äôimportanza di prendere decisioni ingegneristiche basate su principi chiari e non su mode temporanee o preferenze personali. Scrivere buon codice non riguarda solo la sintassi o l‚Äôuso di framework moderni, ma il rispetto di principi fondamentali che rendono il software sostenibile.
                        <br><br>üîπ <b>L‚ÄôImportanza della Manutenzione</b><br>
                        Kanat-Alexander sottolinea che la maggior parte del lavoro degli sviluppatori non √® scrivere nuovo codice, ma mantenere e migliorare quello esistente. Di conseguenza, ogni scelta fatta nello sviluppo deve tenere conto della futura manutenzione del software.
                    </p>
                    <br>
                    <h4></h4>
                    <p>
                        Il messaggio principale di Code Simplicity √® che scrivere buon codice non significa scrivere codice complesso, ma piuttosto ridurre la complessit√† il pi√π possibile. Il software migliore non √® quello pi√π sofisticato o avanzato, ma quello che risolve problemi nel modo pi√π chiaro ed efficace.
                        Kanat-Alexander invita gli sviluppatori a pensare al lungo termine, a evitare scorciatoie che potrebbero generare debito tecnico e a dare priorit√† alla semplicit√† come valore fondamentale nella progettazione del software.
                    </p>
                
                <!-- <div class="right-about">
                    <img src="https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQ6gyaaEzjoUCA2f3dItZDsR2yN_cAXUwOw0kUPsp1byirHMzDJ" alt="Code Simplicity Max Kanat-Alexander" class="about-img">
                </div>         -->
            </div>
            <h4 class="stat-title">Citazioni</h4>
            <div class="timeline">
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        The equation of Software Design: D=V/E
                        <br/>
                        <b>D</b>, stands for the desirability of a change. How much do we want to do something? <br/>
                        <b>V</b>, stands for the value of a change. How valuable is this change? Usually, you would determine this by asking ‚ÄúHow much does this help our users?‚Äù although there are other methods of determining value as well.<br/>
                        <b>E</b>, stands for the effort involved in performing the change. How much work will the change require?<br/>
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        It is more important to reduce the effort of maintenance than it is to reduce the effor of implementation.
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        Code should be designed based on what you know now, not on what you think will happen in the future.
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        The change of introducing a defect into your program is proportional tothe size of the changes you make to it.
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        The best design is the one that allows for the most change in the environment with the least change in the software.
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        The ease of maintenance of any piece of software is proportional to the simplicity of its individual pieces.
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        It‚Äôs not a matter of intelligence, it‚Äôs a matter of knowledge
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        Really, there is no need to get fancy and complex and try to do 500 things at once in a single program. Users are happiest with a focused, simple product that never violates its basic purpose.
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        Thankfully, there are three factors you can look at to determine if a technology is ‚Äúbad‚Äù before you even start using it: survival potential, interoperability, and attention to quality.
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        Any time there‚Äôs an ‚Äúunsolvable complexity‚Äù in your program, it‚Äôs because there is something fundamentally wrong with the design. If the problem appears unsolvable at one level, back up and look at what might be underlying the problem. 
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        The degree to which you know how your software behaves is the degree to which you have accurately tested it.
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        The Law of Change: The longer your program exists, the more probable it is that any piece of it will have to change. 
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        The Law of Defect Probability: The change of introducing a defect into your program is proportional to the size of the changes you make to it
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        The Law of Simplicity: The ease of maintenance of any piece of software is proportional to the simplicity of its individual pieces.
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        The Law of Testing: The degree to which you know how your software behaves is the degree to which you have accurately tested it.
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        If you wanted to sum up the most important facts to keep in ming about software design in two simple sentences, they would be
It is more important to reduce the effort of maintenance than it is to reduce the effort of implementation
The effort of maintenance if proportional to the complexity of the system

                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        The three mistakes (called ‚Äúthe three flaws‚Äù in this book) that software designers are prone to making in coping with the Law of Change are:
Writing code that isn‚Äôt needed
Not making the code easy to change
Being too generic
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        Don‚Äôt write code until you actually need it, and remove any code tahat isn‚Äôt being used
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        Code should be designed based on what you know now, not on what you think will happen in the future
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        Never fix anything unless it‚Äôs a problem, and you have evidence showing that the problem really exists
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        Comments should explain why the code is doing something, not what it is doing
                    </p>
                </div>
                <div class="timeline-item">
                    <div class="tl-icon">
                        <i class="fas fa-book"></i>
                    </div>
                    <p>
                        When your design actually makes things more complex instead of simplifying things, you‚Äôre overengineering
                    </p>
                </div>
            </div>
        </section>
    </main>

    <div class="controls">
        <a href="../index.html">
            <div class="control" data-id="home" >
                <i class="fas fa-home"></i>
            </div>
        </a>
         <!-- <a href="../index.html#about">
            <div class="control" data-id="about">
                <i class="fas fa-user"></i>
            </div>
        </a> -->
        <!--<a href="../index.html#portfolio">
            <div class="control" data-id="portfolio">
                <i class="fas fa-briefcase"></i>
            </div>
        </a>
        <a href="../index.html#books">
            <div class="control" data-id="books">
                <i class="fas fa-book"></i>
             </div>
        </a>
         <a href="../index.html#contact">
            <div class="control" data-id="contact">
                <i class="fas fa-envelope-open"></i>
            </div>
         </a> -->
    </div>
    <div class="theme-btn">
        <i class="fas fa-adjust"></i>
   </div>
   <script src="../app.js"></script>
</body>
</html>